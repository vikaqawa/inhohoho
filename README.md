# LESSON 60
## VOPROSI I ZADANIA

1) Функция — это блок кода, который выполняет определённую задачу и возвращает результат. В отличие от процедуры, которая выполняет действия, но не возвращает значение, функция должна иметь возвращаемый тип данных. 

2) Пример функции в Паскале:


pascal

 Копировать код

function NameOfFunction(parameters): returnType;

begin

  // body of the function
  
  Result := someValue;

end;

Пример функции в школьном алгоритмическом языке:


scss

 Копировать код

Функция NameOfFunction(parameters) : returnType

  body of the function
  
  Вернуть someValue

КонецФункции

3) На Паскале возвращаемое значение функции указывается через специальную переменную Result или может быть указано в конце блока функции:


pascal

 Копировать код

function Add(a, b: Integer): Integer;

begin

  Result := a + b; // Возвращает сумму

end;

В этом примере функция Add возвращает значение типа Integer, которое является суммой a и b.

4. Какие функции называются логическими? Зачем они нужны?

Логические функции — это функции, которые возвращают значения типа Boolean (Истина или Ложь). Они необходимы для проверки условий, например, для валидации данных или выполнения логических операций.

Примеры функций
1. Функция, которая вычисляет максимальное из трёх чисел:

pascal

 Копировать код
function MaxOfThree(a, b, c: Integer): Integer;
begin
  if (a > b) and (a > c) then
    Result := a
  else if (b > c) then
    Result := b
  else
    Result := c;
end;
2. Функция, которая вычисляет одновременно максимальное и минимальное из трёх чисел (используя изменяемые параметры):

pascal

 Копировать код
procedure MinMaxOfThree(a, b, c: Integer; var min, max: Integer);
begin
  min := a; max := a;
  if b < min then min := b;
  if c < min then min := c;
  if b > max then max := b;
  if c > max then max := c;
end;
3. Функция, которая вычисляет количество цифр числа:

pascal

 Копировать код
function CountDigits(n: Integer): Integer;
begin
  Result := 0;
  while n > 0 do
  begin
    n := n div 10;
    Result := Result + 1;
  end;
end;
4. Функция, которая вычисляет наибольший общий делитель (НОД) двух чисел:

pascal

 Копировать код
function GCD(a, b: Integer): Integer;
begin
  while b <> 0 do
  begin
    Result := b;
    b := a mod b;
    a := Result;
  end;
  Result := a;
end;
5. Функция, которая вычисляет наименьшее общее кратное (НОК) двух чисел:

pascal

 Копировать код
function LCM(a, b: Integer): Integer;
begin
  Result := (a * b) div GCD(a, b);
end;
6. Функция, которая «разворачивает» десятичную запись числа:

pascal

 Копировать код
function ReverseNumber(n: Integer): Integer;
var
  reversed: Integer;
begin
  reversed := 0;
  while n > 0 do
  begin
    reversed := reversed * 10 + n mod 10;
    n := n div 10;
  end;
  Result := reversed;
end;
7. Функция, которая моделирует бросание двух игральных кубиков:

pascal

 Копировать код
function RollDice: Integer;
begin
  RollDice := Random(6) + 1; // Генерация случайного числа от 1 до 6
end;

procedure RollTwoDice(out die1, die2: Integer);
begin
  die1 := RollDice;
  die2 := RollDice;
end;
8. Функция, вычисляющая факториал натурального числа:

pascal

 Копировать код
function Factorial(n: Integer): Integer;
begin
  if n = 0 then
    Result := 1
  else
    Result := n * Factorial(n - 1);
end;
9. Функция, вычисляющая N-е число Фибоначчи:

pascal

 Копировать код
function Fibonacci(n: Integer): Integer;
begin
  if n <= 1 then
    Result := n
  else
    Result := Fibonacci(n - 1) + Fibonacci(n - 2);
end;
10. Функция для поиска дружественных чисел:

pascal

 Копировать код
function SumOfDivisors(n: Integer): Integer;
var
  i, sum: Integer;
begin
  sum := 0;
  for i := 1 to n div 2 do
    if n mod i = 0 then
      sum := sum + i;
  Result := sum;
end;

procedure FindAmicableNumbers(limit: Integer);
var
  i, sum1, sum2: Integer;
begin
  for i := 1 to limit do
  begin
    sum1 := SumOfDivisors(i);
    sum2 := SumOfDivisors(sum1);
    if (sum2 = i) and (i <> sum1) then
      WriteLn('Дружественная пара: ', i, ' и ', sum1);
  end;
end;
11. Программа для нахождения чисел, сумма цифр которых не меняется при умножении на 2, 3, ..., 9:

pascal

 Копировать код
function SumOfDigits(n: Integer): Integer;
begin
  Result := 0;
  while n > 0 do
  begin
    Result := Result + (n mod 10);
    n := n div 10;
  end;
end;

procedure FindSpecialNumbers(N: Integer);
var
  i: Integer;
begin
  for i := 0 to N do
    if (SumOfDigits(i) = SumOfDigits(i * 2)) and
       (SumOfDigits(i) = SumOfDigits(i * 3)) and
       (SumOfDigits(i) = SumOfDigits(i * 4)) and
       (SumOfDigits(i) = SumOfDigits(i * 5)) and
       (SumOfDigits(i) = SumOfDigits(i * 6)) and
       (SumOfDigits(i) = SumOfDigits(i * 7)) and
       (SumOfDigits(i) = SumOfDigits(i * 8)) and
       (SumOfDigits(i) = SumOfDigits(i * 9)) then
      WriteLn(i);
end;

### ZADACHI

1. Логическая функция для проверки, является ли число N совершенным:
pascal

 Копировать код
function IsPerfect(N: Integer): Boolean;
var
  i, sum: Integer;
begin
  sum := 0;
  for i := 1 to N div 2 do
  begin
    if N mod i = 0 then
      sum := sum + i;
  end;
  IsPerfect := (sum = N);
end;

Пример использования:
pascal

 Копировать код
var
  N: Integer;
begin
  Write('Введите число N: ');
  ReadLn(N);
  if IsPerfect(N) then
    WriteLn(N, ' является совершенным числом.')
  else
    WriteLn(N, ' не является совершенным числом.');
end;
2. Логическая функция для проверки, является ли число N гиперпростым (используя уже готовую функцию isPrime):
pascal

 Копировать код
function IsPrime(num: Integer): Boolean;
var
  i: Integer;
begin
  if (num <= 1) then
    Exit(False);
  for i := 2 to Trunc(Sqrt(num)) do
  begin
    if num mod i = 0 then
      Exit(False);
  end;
  Exit(True);
end;

function IsHyperPrime(N: Integer): Boolean;
var
  strN: String;
  i: Integer;
begin
  strN := IntToStr(N);

  // Проверка самого числа
  if not IsPrime(N) then
    Exit(False);

  // Проверка всех возможных комбинаций
  for i := 1 to Length(strN) do
  begin
    if IsPrime(StrToInt(Copy(strN, 1, i))) = False then
      Exit(False);
  end;

  IsHyperPrime := True;
end;

Пример использования:
pascal
var
  N: Integer;
begin
  Write('Введите число N: ');
  ReadLn(N);
  if IsHyperPrime(N) then
    WriteLn(N, ' является гиперпростым числом.')
  else
    WriteLn(N, ' не является гиперпростым числом.');
end;
Объяснения:

Совершенное число: Функция IsPerfect вычисляет сумму делителей числа N (меньших самого N) и проверяет, равна ли эта сумма самому числу.

Гиперпростое число: Функция IsHyperPrime сначала проверяет, является ли число простым с помощью функции IsPrime. Затем она проверяет все возможные числа, полученные отбрасыванием цифр, начиная с самой левой цифры.

# LESSON 61

## VOPROSI

1. Рекурсией называется ситуация, когда некоторый объект содержит в своём описании самого себя, то есть является своей частью. Если кратко, рекурсия позволяет уходить от простейших императивно написанных итераций к более декларативному стилю написания кода. Примеры рекурсии. Живым примером рекурсии является рост дерева – из ствола дерева растут более маленькие деревья – ветки, из них ещё ветки, и так далее, пока не останутся только листья.

2. Рекурсивное определение состоит из двух частей, потому что одна часть определяет понятие через него же, а другая — через иные понятия.

3. Рекурсивная процедура — это процедура, которая в процессе выполнения вызывает сама себя.

4. "Ханойская башня" является одной из популярных головоломок XIX века. Даны три стержня, на один из которых нанизаны восемь колец, причем кольца отличаются размером и лежат меньшее на большем. Задача состоит в том, чтобы перенести пирамиду из восьми колец за наименьшее число ходов на другой стержень. За один раз разрешается переносить только одно кольцо, причём нельзя класть большее кольцо на меньшее. 
Шаги алгоритма: 

Определить два стержня или колышка в качестве источника и назначения, а запасной колышек сделать вспомогательным. 
Переместить верхние n-1 дисков с исходной привязки на вспомогательную. 
После этого переместить n-й диск с исходной привязки на целевую. 
Наконец, переместить оставшиеся n-1 дисков со вспомогательной привязки на целевую. 

5. Процедуру Б можно назвать рекурсивной в описанной ситуации, так как она вызывает процедуру А и саму себя. 

6. Рекурсия никогда не остановится, если забыть прописать условие выхода из неё. В этом случае она будет выполняться бесконечно, и выйти из неё можно только принудительным закрытием программы. 
Чтобы этого не случилось, нужно ещё в процессе написания кода создать условие выхода из рекурсии. При этом необходимо убедиться, что это условие будет достигнуто. Например, если прописать условие, но не вычитать из параметра единицу, а прибавлять её, условие никогда не наступит, и рекурсия станет бесконечной.

7. Стек вызовов (call stack) — это структура данных, которая управляет вызовами функций во время выполнения программы. Когда программа выполняется на компьютере, то он поочередно вызывает разные функции, отвечающие за конкретные действия (подпрограммы). При этом в стеке хранятся данные о вызове функций в виде точек перехода — моментов, когда компьютер прервал выполнение одной функции и перешел к другой.

8. Переполнение стека при использовании рекурсии может случиться по нескольким причинам:

Бесконечная рекурсия.  Если функция вызывает саму себя слишком много раз, то каждый новый вызов функции добавляет новый элемент в стек. Если глубина рекурсии слишком большая, то стек может переполниться. 
Ошибки в намеренной рекурсии. Например, ошибка в условии окончания рекурсии или в рекурсивном спуске. 
Большие переменные в стеке. Одноразовое выделение огромного количества памяти крупными локальными переменными может привести к переполнению стека, если в нём нет такого количества памяти. 
9. Недостатки рекурсии

Рекурсивные функции могут потреблять большое количество памяти из-за множественных вызовов функции в стеке вызовов
Они могут быть менее эффективными по времени выполнения из-за накладных расходов на управление стеком вызовов
Когда следует использовать рекурсию: если для приложения важна скорость работы и низкая нагрузка, а также существует риск переполнения памяти, лучше отдавать предпочтение циклам.  Если скорость не так важна, а реализация без рекурсии отнимет много времени и строк кода — лучше воспользоваться рекурсивным подходом.
Достоинства рекурсии

Достоинства рекурсии:

Простота и читаемость кода. Рекурсивные решения часто более элегантны и проще для понимания. 
Решение сложных задач. Некоторые задачи, такие как обход деревьев, проще решать рекурсивно. 
Математическая интуиция. Рекурсивные алгоритмы часто имеют прямую связь с математическими определениями и теоремами.

## ZADACHI


1. в центре рисунка — большая окружность. На ней находятся центры четырёх окружностей меньшего диаметра, на каждой из которых — центры ещё четырёх окружностей ещё меньшего диаметра и т. д.. Всего — N разных диаметров (N уровней рекурсии).


3. Задаем рекурсивную функцию, которая может принимать в качестве аргумента число. 
Принимаем от пользователя число и передаём его в качестве аргумента в рекурсивную функцию. 
В самой функции в качестве базового условия рекурсии задаём равенство входящего аргумента нулю. В этом случае функция возвращает переменную, в которую до начала работы функции был помещён пустой список. 
В противном случае в список добавляется остаток от деления аргумента на 2, а затем снова вызывается эта же функция, в которую в качестве аргумента передаётся результат целочисленного деления на 2. 
Далее переворачиваем список и выводим его на экран при помощи цикла for.


5. Если входные данные состоят из двух или более символов, то проблема разделяется на две части: строка, исключая последнюю двоичную цифру, и последний символ. Эти две части решаются независимо, а затем объединяются. 
Умножение первого результата на 2. Это нужно, потому что опущена последняя цифра, а в двоичном формате такое упущение означает, что число разделили на 2. 
Добавление значения для последней цифры (другой рекурсивный вызов).

6. 
рекурсивная 
function NOD(x, y: integer): integer;
begin
    if x<>0 then NOD:=NOD(y mod x, x) else NOD:=y;
end;
var a, b: integer;
begin
    write('a='); readln(a);
    write('b='); readln(b);
    writeln('НОД =', NOD(a, b));
end. 

нерекурсивная 

function NOD(x, y: integer): integer;
begin
    while (x<>0)and(y<>0) do
        if x>y then x:=x mod y else y:=y mod x;
    NOD:=x+y;
end;
var a, b: integer;
begin
    write('a='); readln(a);
    write ('b='); readln(b);
    writeln('НОД=',NOD(a, b));
end. 

